

## 4static用法

- C语言
  - 函数内修饰变量：变量的生存周期长于函数。只初始化一次。使用静态变量的函数一般是不可重入的，也不是线程安全的
  - 文件级修饰（函数体之外）：修饰变量或函数，表示变量或函数只在本文件可见，其他文件不可访问
- C++（引入类，多了2种新用法）
  - 修饰类数据成员：静态成员变量生存周期大于类对象，每个class一份。类内声明，类外初始化
  - 修饰类成员函数：只能访问静态成员变量和其他静态成员函数。没有this指针，所以不能访问非静态成员变量和非静态成员函数

关于静态变量：
用static修饰的类成员变量和成员函数具有全局作用域，但静态成员函数没有this指针。
用static修饰的全局变量被称为静态全局变量，具有文件作用域，只在编译单元有效。
用static修饰的局部变量被称为静态局部变量，作用域不变。
静态变量具有唯一性。



## 数组名和&数组名

```c
#include <stdio.h>

int main(void)
{
    int array[5] = {0};

    printf("1.          array = %p\n", array); 
    printf("2.         &array = %p\n", &array); 
    printf("3.      &array[0] = %p\n", &array[0]); 
    printf("4.      array + 1 = %p\n", array + 1);
    printf("5.  &array[0] + 1 = %p\n", &array[0] + 1);
    printf("6.     &array + 1 = %p\n", &array + 1);
    printf("7.  sizeof(array) = %lu\n", sizeof(array)); 

    return 0;
}
/*
1.          array = 0x7ffd032e4e80
2.         &array = 0x7ffd032e4e80
3.      &array[0] = 0x7ffd032e4e80
4.      array + 1 = 0x7ffd032e4e84
5.  &array[0] + 1 = 0x7ffd032e4e84
6.     &array + 1 = 0x7ffd032e4e94
7.  sizeof(array) = 20
*/
```

![image-20200121171758014](C:\Users\x00422359\AppData\Roaming\Typora\typora-user-images\image-20200121171758014.png)

&array的类型时实际为int (*)[5]；所以每次+1实际会前进5个int整数（前进一行）



### char *与char[]区别

```c
char str1[] = "C Language";
char *str2 = "C Language";
str1[1] = '-';
*(str2+1) = '-';  //错！不能改变字符串常量的值
printf("str1 = %s\n", str1);
```

字符串指针指向的是一个常量字符串，存放在静态区，一旦定义就无法改变



## 动态申请二维数组

**利用二级指针申请**

```c
int m, n; //m行，n列
int **a = (int **)malloc(sizeof(int *) * m);
for (i = 0; i < m; i++) {
    a[i] = (int *)malloc(sizeof(int) * n);
}
for (i = 0; i < m; i++) {
    for (j = 0; j < n; j++) {
        printf("%p\n", &a[i][j]); // 打印每个元素地址，每行的列与列之间是连续的，行与行之间地址不连续
    }
}
//释放
for (i = 0; i < m; i++) {
    free(a[i]);
}
free(a);
```

**用数组指针形式申请**

```c
int (*a)[3] = (int(*)[3])malloc(sizeof(int) * 5 * 3);
for (i = 0; i < 5; i++) {
    for (j = 0; j < 3; j++) {
        printf("%p\n", a[i][j]); //每个元素地址都是连续的
    }
}
free(a);
```

**用一维数组模拟二维数组**

```c
int *a = (int *)malloc(sizeof(int) * 5 * 3);
for(i = 0; i < 5; i++) {
    for (j = 0; j < 3; j++) {
        printf("%d\n". a[i*5+j]); //i*column+j访问第i,j个元素
    }
}
free(a);
```

**二维数组不等于二级指针，直接把二级指针赋给`int (*m)[n]`会报warning**

![image-20200127135929416](C:\Users\x00422359\AppData\Roaming\Typora\typora-user-images\image-20200127135929416.png)

一个例子

```c
int a[m][n];
int (*p)[n] = &a[i]; //ok，因为类型完全一样
int (*p)[n] = a[i]; //类型不一样，不行
```

`a[i]`是类型是数组int [n];  `&a[i]`类型是指针，指向维度为n的数组，每次+1前进一行

`p=a`没有问题，因为a就是`a[0]`的地址即`&a[0]`，所以 a类型为`int (*)[n]`



### 指针数组与数组指针区别

数组指针：int (*p)[4]，()优先级高，说明p是一个指针，只是一个指针变量，p+1每次跳4个int的长度

指针数组：int *p[5]，[]优先级高，说明是个数组，数组有5个元素，每个元素都是int *类型





## 指针函数与函数指针

指针函数：

​		本质是函数，函数返回值是某类型的指针

函数指针：

​		本质是指针。声明格式： `函数返回值 (*函数名)(函数参数)`  (实际上函数名叫做指针变量名更合适)

```c
int func(int x);

int (*f) (int x); // 声明一个函数指针变量f

// 函数的地址赋给函数指针,有2种方式:
fptr = &func;
fptr = func;   // &不是必须的，因为函数名就表示了地址

// 通过函数指针来调用函数：
x = (*fptr)(a);
x = fptr(a);
```

两种调用方式结果一样，推荐第一种，更能明确指出是通过函数指针而非函数本身来调用函数的



指针函数与函数指针表示方法的不同，辨别方式就是看函数名前面的指针*号有没有被括号（）包含，如果被包含就是函数指针，反之则是指针函数。



==注意：==类对象成员函数指针与普通指针函数不同，**成员函数指针赋值一定要用`&`取地址符**（普通函数可选）：

​		因为函数名作为函数指针是隐式转换。对于C++规定非静态成员函数的左值不可获取，因此不存在隐式左值转换，即不能想普通函数到函数指针的隐式转换，必须用`&`获取函数的地址赋给函数指针变量

通过成员函数创建线程需要传this指针绑定

Ref：

https://bbs.csdn.net/topics/390573179?page=1

https://blog.csdn.net/Sy__TenMoons/article/details/89598613

https://segmentfault.com/a/1190000006232497



## 虚函数&&纯虚函数

虚函数：为了实现多态，允许用基类的指针来调用子类的这个函数。

纯虚函数：是为了实现一个接口，起到一个规范的作用，规范继承这个类的程序员必须实现这个函数。
1、简介
假设我们有下面的类层次：

```c++
class A
{
public:
    virtual void foo()
    {
        cout<<"A::foo() is called"<<endl;
    }
};
class B:public A
{
public:
    void foo()
    {
        cout<<"B::foo() is called"<<endl;
    }
};
int main(void)
{
    A *a = new B();
    a->foo();   // 在这里，a虽然是指向A的指针，但是被调用的函数(foo)却是B的!
    return 0;

}
```



当一个类本身定义了虚函数，或其父类有虚函数时，为了支持多态机制，编译器将为该类添加一个虚函数指针（vptr）。虚函数指针一般都放在对象内存布局的第一个位置上，这是为了保证在多层继承或多重继承的情况下能以最高效率取到虚函数表

https://blog.csdn.net/hackbuteer1/article/details/7558868

https://www.cnblogs.com/qg-whz/p/4909359.html





## 智能指针

智能指针转普通指针

```c++
shared_ptr<int> sp;
void * tmp = (int *)sp.get();
```

shared_ptr线程安全：

1. 同一个shared_ptr对象可以被多线程同时读取。

2. 不同的shared_ptr对象可以被多线程同时修改。

3. 同一个shared_ptr对象不能被多线程直接修改，但可以通过原子函数完成。

如果把上面的表述中的"shared_ptr"替换为“内置类型”也完全成立。



shared_ptr循环引用：

https://blog.csdn.net/daniel_ustc/article/details/23096229#t2

### unique_ptr

初始化

```c++
unique_ptr<string> p1(new string("str"));
unique_ptr<string> p2(p1);  //错误，不支持拷贝，而且也不支持赋值
unique_ptr<string> p3 = make_unique<string>(8,'d');//C++11标准库还不支持make_unique，所以在C++14之前都必须采用直接初始化的形式
```

**传递unique_ptr参数和返回unique_ptr**：虽然unique_ptr一般情况下不允许拷贝，但是我们可以拷贝或赋值一个将要销毁的unique_ptr



unique_ptr的删除器定义与shared_ptr不同。

` unique_ptr<T,D> uptr; //uptr使用一个类型为D的可调用对象来释放他的指针`



### weak_ptr

```c++
shared_ptr<int> p1 = make_shared<int>(7);
weak_ptr<int> wp2(p1); //必须要使用shared_ptr来初始化
```

weak_ptr并不统计引用数，所以可能其指向的内存已经被释放，所以使用前需要做一下判断，必须调用lock

```c++
if (shared_ptr<int> p = wp2.lock()) {
    //如果p不为空则成立
}
```





https://blog.csdn.net/qq_33266987/article/details/78784852





## delete && delete[]

new和delete不是函数，是C++定义的关键字

new与malloc区别：new不仅申请了空间，还可以初始化申请的内存



对于普通类型，delete和delete[]没有区别

对于class类型，delete只能释放第一个class对象（调用析构），delete[]会逐一调用每个class对象的析构



​		对于没有自定义析构器的class或者struct，在delete时不需要调用其析构器，所以可以将整块数组当成一个整体来处理，也就可以使用delete直接释放这一整块内存空间。
​		而对于自定义了析构器的class或者struct，在delete时需要逐个调用其析构器，所以需要有标识位记录数组大小，然后通过数组大小来逐个调用其析构器，再释放内存。





对于内置类型而言，new仅仅是分配内存，除非后面显示加(),相当于调用它的构造函数，对于自定义类型而言，只要一调用new，那么编译器不仅仅给它分配内存，还调用它的默认构造函数初始化，即使后面没有加()





对象数组复用构造函数：

```c++
char *p = new char[sizeof(MyObj)*n]
new(p+sizeof(MyObj)*i) MyObj(args) // placement new
```







Ref：

https://blog.csdn.net/nodeathphoenix/article/details/39693865

https://www.runoob.com/note/15971

https://blog.csdn.net/qq_36576410/article/details/88760160

##  可变模板参数（variadic templates）

​		C++11新增特性之一，能表示0到任意个数，任意类型的参数。(C中可以通过stdarg.h头文件使用可变参数，但参数类型必须一致)

```c++
//template<class... T>
template<typename... T>
void f(T... args);
```

`args`是参数包，类型是`T... `，如果要获取参数包的具体类容，通过`args...`展开参数包，得到具体的参数。

`sizeof...()`可以获取`args`参数包的具体参数个数。

展开可变模板参数函数方式：

- 通过参数明确的递归终止函数来展开参数包
- 通过逗号表达式来展开参数包

```c++
#include <iostream>
using namespace std;

//递归终止函数
template<typename T>
void myprint(T end)//递归到最后一次，调用单参数函数
{
	cout << "parameter " << end << endl;
}
//展开函数
template<typename T,class ...Args>
void myprint(T head, Args... rest)
{
    cout << "parameter " << head << endl;
    myprint(rest...);   // 注意是rest...  不是rest
}

int main()
{
    myprint(1, 2, 3, 4);
    return 0;
}
```

模板函数编程遇到的问题：

​		模板函数代码实现必须在头文件中，否则会链接时报未定义引用的错误

​		（因为编译器需要知道实例化点的完整类型）

![image-20200326234414554](C:\Users\x00422359\AppData\Roaming\Typora\typora-user-images\image-20200326234414554.png)

编译不报错，链接时报错：

![image-20200326234549367](C:\Users\x00422359\AppData\Roaming\Typora\typora-user-images\image-20200326234549367.png)

如果将模板函数实现放在头文件中就没有问题：

![image-20200326234838637](C:\Users\x00422359\AppData\Roaming\Typora\typora-user-images\image-20200326234838637.png)

注意：如果是只有头文件和主函数的cpp文件，实现放在cpp文件中也没有问题。因为没有链接的过程。



当实例化一个模板时，编译器必须看到模板确切的定义，而不仅仅是它的声明。因此，最好的办法就是将模板的声明和定义都放置在同一个.h文件中。这就是为什么所有的STL头文件都包含模板定义的原因

所有的STL头文件都包含了模板的实现定义



普通函数：

​	声明放在头文件中，定义放在源文件中，其它的地方要使用该函数时，仅需要包含头文件即可，因为编译器编译时是以一个源文件作为单元编译的，当它遇到不在本文件中定义的函数时，若能够找到其声明，则会将此符号放在本编译单元的外部符号表中，链接的时候自然就可以找到该符号的定义了。

模板函数：

​	首先明确，模板函数是在编译器遇到使用模板的代码时才将模板函数实例化的。若将模板函数声明放在tem.h，模板定义放在tem.cpp,在main.cpp中包含头文件，调用add,按道理说应该实例化int add(int,int)函数，即生成add函数的相应代码，但是此时仅有声明，找不到定义，因此此时，它只会实例化函数的符号，并不会实例化函数的实现，即这个时候，在main.o编译单元内，它只是将add函数作为一个外部符号，这就是与普通函数的区别，对普通函数来说，此时的add函数已经由编译器生成相应的代码了，而对模板函数来说，此时并没有生成add函数对应的代码。此时编译main.cpp单元不会报错，但链接就会出现add函数未定义的错误。

ref：https://blog.csdn.net/cllcsy/article/details/50485324



​		当编译器遇到一个模板定义时，它并不生成代码。只有我们实例化出模板的一个特定版本时，编译器才会生成代码。

​		一般情况，当我们调用一个函数时，编译器只需要掌握函数的声明。当我们使用一个类类型的对象时，类的定义必须可用，但是成员函数的定义不一定已经出现。因此，我们把类的定义和函数声明放在头文件，普通函数和类的成员函数放在源文件中。

​		但是对于模板来说，为了生成一个实例化版本，编译器需要掌握函数模板或类模板成员函数的定义，因此，我们也将模板的定义放在头文件里面。







设计模式

如何设计一个类：

https://juejin.im/post/5b9526c1e51d450e69731dc2



构造函数

https://blog.csdn.net/hemmingway/article/details/7853713







## 面向对象

### 构造的执行顺序：

成员对象初始化的次序由声明的次序决定。是因为类的声明是唯一的，而类的构造函数可以有多个，因此会有多个不同次序的初始化表。如果成员对象按照初始化表的次序进行构造，这将导致析构函数无法得到唯一的逆序。

1. 先执行静态成员的构造函数，如果静态成员只是在类定义中声明了，而没有实现，是不用构造的。必须初始化后才执行其构造函数
2. 虚拟基类的构造函数按照它们被继承的顺序构造
3. 非虚拟基类的构造函数按照它们被继承的顺序构造
4. 成员对象的构造函数按照它们声明的顺序调用
5. 类自己构造函数



代码参考：（博客顺序写的是错的）

https://blog.csdn.net/zhangkaihang/article/details/7542621#



```c++
C c;
void main()
{
    A*pa=new A();
    B b;
    static D d;
    delete pa;
}
// 析构顺序为 ABDC
```

全局变量和静态局部变量时从 静态存储区中划分的空间，二者的区别在于作用域的不同，全局变量作用域大于静态局部变量（只用于声明它的函数中），

先释放 D 在释放 C的原因是，C是全局对象,对它的初始化是在main函数之前。析构函数的调用与构造函数的调用顺序刚好相反，所以析构时候要放在最后程序中



### 虚拟继承

虚拟基类是为解决多重继承而出现的。虚拟继承在一般的应用中很少用到，主要是因为在C++中，多重继承是不推荐的，也并不常用，而一旦离开了多重继承，虚拟继承就完全失去了存在的必要因为这样只会降低效率和占用更多的空间。



假设derived 继承自base类，那么derived与base是一种“is a”的关系，即derived类是base类，而反之错误；

假设derived 虚继承自base类，那么derivd与base是一种“has a”的关系，即derived类有一个指向base类的vptr。

虚继承已完全破坏了继承体系，不能按照平常的继承体系来进行类型转换

https://www.cnblogs.com/BeyondAnyTime/archive/2012/06/05/2537451.html

https://blog.csdn.net/dqjyong/article/details/8029527



虚继承底层实现原理与编译器相关，一般通过虚基类指针和虚基类表实现，每个虚继承的子类都有一个虚基类指针（占用一个指针的存储空间，4字节）和虚基类表（不占用类对象的存储空间）（需要强调的是，虚基类依旧会在子类里面存在拷贝，只是仅仅最多存在一份而已，并不是不在子类里面了）；当虚继承的子类被当做父类继承时，虚基类指针也会被继承。



多重虚继承也只有一个虚基类指针

https://www.cnblogs.com/jiaochen/p/5524335.html





构造函数：（ST面）

https://www.cnblogs.com/chio/archive/2007/10/20/931043.html

https://www.cnblogs.com/luxiaoxun/archive/2012/08/10/2631812.html





## 拷贝构造和拷贝赋值

![image-20200629193337621](C:\Users\x00422359\AppData\Roaming\Typora\typora-user-images\image-20200629193337621.png)



拷贝构造：

​		使用传入的对象的值**生成一个新的对象实例**

​		使用场景：

  1. 对象作为函数的参数，以值传递的方式传给函数 （引用方式传递，什么都不调）

  2. 对象作为函数的返回值，以值的方式从函数返回 （引用方式传递，什么都不调）

  3. 使用一个对象给另一个对象**初始化**

     

     ==拷贝构造的参数必须为引用原因：==

     ​	 如果拷贝构造函数中的参数不是一个引用，即形如CClass(const CClass c_class)，那么就相当于采用了传值的方式(pass-by-value)，而传值的方式会调用该类的拷贝构造函数，从而造成无穷递归地调用拷贝构造函数。因此拷贝构造函数的参数必须是一个引用。
     ​       需要澄清的是，传指针其实也是传值，如果上面的拷贝构造函数写成CClass(const CClass* c_class)，也是不行的。事实上，只有传引用不是传值外，其他所有的传递方式都是传值

     **拷贝构造函数的参数使用引用类型不是为了减少一次内存拷贝， 而是避免拷贝构造函数无限制的递归下去**

     Ref：https://blog.csdn.net/Hackbuteer1/article/details/6545882



拷贝构造比直接构造函数效率低：

```c++
class ClassTest
{
public:
	ClassTest(int val)   // 直接构造函数
	{
		cout << "construtor" << endl;
		this->val = val;
	}
	ClassTest(const ClassTest& p)   // 拷贝构造
	{
		cout << "Copy Constructor" << endl;
		this->val = p.val;
	}
	ClassTest& operator=(const ClassTest& p)  // 拷贝赋值
	{
		cout << "Assign" << endl;
		return *this;
	}
private:
	int val;
};
// 首先会使用指定的构造函数生成一个临时对象，然后调拷贝构造复制到真正创建的对象
ClassTest ct2;
ct2 = 2;
// 如下创建实际上编译器可能会优化，看到的是直接只调用了一次构造。没有临时对象生成
ClassTest ct2 = 2;
```



拷贝赋值：

​	将对象的值复制给一个**已存在的实例**

```c++
people p("xieyi",30);
people p2 = p; // 调用的是拷贝构造，不是拷贝赋值
```

**调拷贝构造函数还是拷贝赋值，主要看是否生成新的对象实例：**

​	**若产生新的对象实例，则调拷贝构造；若没有，调拷贝赋值**



拷贝构造一定要注意浅复制的问题





## 移动构造与移动赋值

拷贝构造函数中，对于指针一定要采用深层复制；而移动构造函数中，对于指针采用浅层复制

移动构造函数的参数是右值引用类型



std::move

实际是将一个左值强转为右值引用。基本等同于类型转换`static_cast<T&&>(lvalue);`

**被转化的左值，其生命期并没有随着左右值的转化而改变**，也就是不会立即析构。



成员没有移动构造时，会调用接收常量左值的拷贝构造函数



Ref：

https://blog.csdn.net/y396397735/article/details/51786198



陈硕：

其实就三种，non-copybale、move-able、copy-able，呈递进关系，我想不出支持copy-able但不支持move-able的例子。大多数的class是第一种，直接禁用copy ctor、assign operator、move ctor就行了。对于第二种，move 也可以交给 unique_ptr 去做。只有少数才需要自己写 move ctor 和 move operator。第三种极少，需要写 copy ctor、move ctor、unified assign operator，也只比C++03多一样。





## 字节对齐

**类&结构体字节大小**

1. 类的普通成员函数以及静态成员函数不占内存

    类的成员函数实际上与普通的全局函数类似，只不过在编译的时候会在成员函数上加一个指针（this）形参，（这非常重要）比如上面的方法可以理解为Show（&a）;这   样调用Show的时候就传入了a的地址。成员函数的地址是全局已知的，对象内存无需保存，对象也并不知道它各个函数的地址（这里理解是其他的途径先调用该函数，再把对象传入函数的形参中）

2. 有虚函数的类中会有一个维护虚函数表的指针，这样会占4个字节，64位编译器是可能是8个字节。

3. 类的属性（成员变量），在实例化一个对象时就为这些数据成员分配了内存，而且他们是相互独立的。

4. 静态成员函数与一般成员函数的区别是没有this指针，因此不能访问非静态的数据成员。

5. 程序中的所有函数位于代码区（C语言内存分配中有代码区用于存放CPU执行的机器指令与代码等，其中还有data数据区，BSS区，堆栈）

6. 静态数据成员不属于某个对象（未初始化的存储在bss区，初始化的存储在data区）

7. 成员变量所占大小存在内存对齐机制（在Struct中也是一样的）

8. 空类占一个字节

    空类也需要实例化，实例化必须要在内存中分配一块地址，编译器一般会默认添加一个字节



**对齐**

​		部分CPU在访问内存的时候要求地址对齐，如果不对齐则会导致访问效率低下。

进行如下定义：

**自然对齐**（数据类型的长度）（变量的内存地址正好位于它长度的整数倍）

1. 对于char型数据，自然对齐的长度为1字节，short为2字节，int为4字节，float也是4字节，当然这些数据类型的对齐长度可能和编译器有关
2. 结构体或者类的自身对齐值：其成员中自身对齐值最大的那个值

**指定对齐**

​	#pragma pack(n)中n值，如果没有指定，则为CPU默认对齐值，32位 默认4字节对齐，64位默认8字节对齐

**有效对齐**

​	自然对齐和指定对齐的最小值

​	结构体对齐步骤：

​		第1步：每个成员变量分别按自己的“有效对齐”作对齐

​		第2步：取所有成员变量的“有效对齐”的最大值，作为结构体的“有效对齐”

​		第3步：结构体成员及结构体自己的起始地址和长度均为其“有效对齐”的整数倍

```c++
typedef struct TestData {
    char a;/* 1字节对齐*/
    short b;/* 2字节对齐*/
    int c;/* 4字节对齐*/
    double d;/* 8字节对齐*/
} Data;
int main(void)
{
    Data myData = { { 0 } };
    printf("Sizeoof(TestData) = %d\n", sizeof(Data));
    printf("Addr_a =0x%llx\n", &myData.a);
    printf("Addr_b =0x%llx\n", &myData.b);
    printf("Addr_c =0x%llx\n", &myData.c);
    printf("Addr_d =0x%llx\n", &myData.d);
    return 0;
}
```

上述代码没有使用#pragma pack(n)指定对齐，因此指定对齐值为系统默认值，运行环境为64位系统，默认对齐值为８字节。

char a放在结构体的起始地址，有效对齐值为min(1,8) = 1字节;

short b自然对齐值为2个字节，有效对齐值为min(2,8)=２字节

int c自然对齐值为4个字节，有效对齐值为min(4,8)=4字节

double d自然对齐值为8个字节，有效对齐值为min(8,8)=8字节

char a放在首地址addrbase，short b的起始地址必须是自己的有效对齐值的整数倍，因此必须为2的倍数，放置在addrbase+2~ addrbase+3,长度为2字节;int c的起始地址必须是自己的有效对齐值的整数倍(4)，因此c的地址为addrbase+4~ addrbase+7，共4个字节；double d的起始地址必须是8的倍数，因此d的地址为addrbase+8~ addrbase15共8个自己，结构体整体占用的长度就是16字节。

如果我们在结构体的后面在增加一个char,则该结构体的大小变为24

基本数据类型长度：

| 类型      | 16位系统/字节 | 32位系统/字节 | 64位系统/字节 |
| --------- | ------------- | ------------- | ------------- |
| char      | 1             | 1             | 1             |
| char*     | 2             | 4             | 8             |
| short     | 2             | 2             | 2             |
| int       | 2             | 4             | 4             |
| long      | 4             | 4             | 8             |
| long long | 8             | 8             | 8             |

https://blog.csdn.net/lanzhihui_10086/article/details/44353381

https://www.cnblogs.com/jiaochen/p/5524335.html



## C++编程规范建议

1. 类成员必须显示初始化。最好定义默认构造函数
2. 成员变量优先使用声明时初始化 和构造函数初始化列表初始化（C++11）
3. 若不需要拷贝/移动函数，最好明确禁止
4. 拷贝构造和拷贝赋值应成对出现或禁止
5. 移动构造和移动赋值应成对出现或禁止
6. 禁止在构造/析构中调用虚函数



RAII

当我们在一个函数内部使用局部变量，当退出了这个局部变量的作用域时，这个变量也就别销毁了；当这个变量是类对象时，这个时候，就会自动调用这个类的析构函数，而这一切都是自动发生的，不要程序员显示的去调用完成。这个也太好了，RAII就是这样去完成的。

由于系统的资源不具有自动释放的功能，而C++中的类具有自动调用析构函数的功能。**如果把资源用类进行封装起来，对资源操作都封装在类的内部，在析构函数中进行释放资源。当定义的局部变量的生命结束时，它的析构函数就会自动的被调用，如此，就不用程序员显示的去调用释放资源的操作了。**

https://zhuanlan.zhihu.com/p/33881856





## 函数参数&函数返回值

参数：

​		参数传递分为值传递和引用传递。（传指针也是值传递）

​		传值会有拷贝，产生较大的消耗

返回值：

1. 返回值（非引用）

   ​	会创建临时对象，拷贝构造生成临时对象。临时对象赋值给调用函数的变量

2. 返回引用

   ​	返回对象本身，没有复制返回值。不会产生副本

   ​	返回的对象一定是在==函数执行完成后仍然存在的==，否则返回引用没有意义，是错误的。

   ​	不希望返回的对象被修改，可返回const引用

   ​	不要返回局部对象的引用（指针也是）

总结：

​		值拷贝会有较大的消耗（当结构体或类很大时更明显），所以尽量用引用或指责作为参数/返回值。（引用更为直观，更提倡）

​		返回指向函数调用后还存在的对象的引用是正确的。不希望返回的对象被修改，返回const引用。



Ref：

https://blog.csdn.net/tlxxm/article/details/8860760



## 临时对象

​		临时对象没有对象名，它的生命周期只有一条语句的时间，作用域也只在这条语句间。

临时对象产生：

- 构造函数作为隐式类型转换函数时，会创建临时对象，用作实参传递给函数
- 函数返回一个对象，会产生临时对象，以返回的对象作为拷贝构造函数的实参构造一个临时对象

```c++
class Person
{
public:
	Person()
	{
		cout << "default constructor" << endl;
	}
	Person(int age)
	{
		cout << "construtor" << endl;
		this->age = age;
	}
	Person(const Person &p)
	{
		cout << "Copy Constructor" << endl;
		this->age = p.age;
	}
	Person& operator=(const Person& p)
	{
		cout << "Assign" << endl;
		return *this;
	}
private:
	int age;
};
int main()
{
	Person p;
	p = f1();
}
/* output
default constructor // 创建p对象
construtor          // f1函数里的对象创建
Copy Constructor    // 拷贝构造给临时对象
Assign              // 临时对象拷贝赋值给p
*/
int main()
{
	Person p = f1();
}
/* output
construtor          // f1函数里的对象创建
Copy Constructor	// 编译器优化，没有临时对象产生。直接拷贝构造给p
*/
```



Ref：

https://www.cnblogs.com/xkfz007/articles/2506022.html

## 左值，右值

左值与右值的根本区别在于能否获取内存地址。通常临时变量都是右值

```c++
#include <iostream>

void process_value(int& i) 
{ 
  std::cout << "LValue processed: " << i << std::endl; 
} 

void process_value(int&& i) 
{ 
  std::cout << "RValue processed: "  << std::endl; 
} 

int main() 
{ 
  int a = 0; 
  process_value(a);
  int&& x = 3;
  process_value(x); 
}
/* output
LValue processed: 0
LValue processed: 3
*/
```

x 是一个右值引用，指向一个右值3，但是由于x是有名字的，所以x在这里被视为一个左值，所以在函数重载的时候选择为第一个函数

https://www.ibm.com/developerworks/cn/aix/library/1307_lisl_c11/

https://blog.csdn.net/xiaolewennofollow/article/details/52559306?depth_1-utm_source=distribute.pc_relevant.none-task-blog-OPENSEARCH-1&utm_source=distribute.pc_relevant.none-task-blog-OPENSEARCH-1

https://blog.csdn.net/hyman_yx/article/details/52044632

https://blog.csdn.net/gg_18826075157/article/details/71977105



## 返回值优化

https://blog.csdn.net/KeLiaoo/article/details/112168423



## 引用

实际上是一个变量的内存地址，既然是内存地址的话，那么肯定可以读写该地址所对应的内存区域的值，即就是“左值”，可以出现在赋值语句的左边

https://www.jb51.net/article/80911.htm

https://blog.csdn.net/ztz0223/article/details/1639305



tip：
左值引用其实是通过指针实现的。
T&&根据引用折叠规则实现了通用引用。
通过值传递函数参数会执行拷贝构造函数。
左值引用可以绑定左值和左值引用；右值引用可以绑定右值和move强制转换的右值引用。
值和常引用可以绑定任何左值、右值、左值引用、右值引用。
使用通用引用时，由于会丢失右值属性，可以通过forward实现完美转发。



## 隐式转换







## 内存模型

```c
int a = 1; // 全局初始化区
char *p1; // 全局未初始化区
int main() {
    int b; // 栈
    char s[] = /"abc/"; // 栈
    char *p2; // 栈
    char *p3 = /"123456/"; //123456//0 在常量区， p3 在栈上。
    static int c =0;// 全局（静态）初始化区
    p1 = new char[10];
    p2 = new char[20];
    // 分配得来得和字节的区域就在堆区。
    strcpy(p1, /"123456/"); //123456//0 放在常量区，编译器可能会将它与 p3 所指向的 /"123456/" 优化成一个地方。
}
```



https://blog.csdn.net/zcyzsy/article/details/69788884

https://blog.csdn.net/wandermen/article/details/48320821



## 虚表

https://blog.csdn.net/lihao21/article/details/50688337

虚表（存放类所有虚函数指针）是一个类一个，虚表存储在只读数据段（代码段）

虚表属于类，虚表指针属于对象实例

多重继承有多个虚表指针



## lambda函数

- lambda的参数列表与捕获列表都是用于接收外部来的变量
- lambda的参数列表是与普通函数一样，用于传递外部参数的，它体现了调用者与被调者的契约，生命周期仅限于本次调用
- lambda的捕获列表是函数对象的构造函数，用于存储外部变量的，它让lambda变得有状态,生命周期与lambda表达式生命周期一致



extern C

https://www.cnblogs.com/xulei/archive/2006/11/12/558139.html



## 多线程

https://www.ibm.com/developerworks/cn/linux/1412_zhupx_thread/index.html

https://blog.csdn.net/hujingshuang/article/details/70237211

https://blog.csdn.net/flyingleo1981/article/details/14227241

### 线程安全



### 锁

https://zhuanlan.zhihu.com/p/91062516

https://blog.csdn.net/c_base_jin/article/details/89741247

https://blog.csdn.net/abc1990fly/article/details/79469216

pthread

https://blog.csdn.net/liujiabin076/article/details/53456962

https://blog.csdn.net/future_fighter/article/details/3865071#pthreads_overview

https://zhuanlan.zhihu.com/p/112297714





虚假唤醒

```c++
std::condition_variable con_var;
...
while(!notified)
    con_var.wait(lock);   // ok,没有问题，不存在虚假唤醒
....
if(!notified) 
    con_var.wait(lock);  // Nok, con_var状态更改后，此线程被唤醒，如果此时notified被另外一个线程又修改成false了，那此线程不需要被唤醒干活->虚假唤醒
```

condition_variable

https://blog.csdn.net/qq_44800780/article/details/104879607

notify_one() 和notify_all()是不需要上锁调用的，如果在锁里调用，可能会导致被立刻唤醒的线程继续阻塞（因为锁被notify线程持有），但c++标准上也说，一些实现（尤其是许多 pthread 的实现）为了归避这种情况，在通知调用中，直接将等待线程从条件变量队列转移到互斥队列，而不唤醒它，来避免此"hurry up and wait"场景

生产者-消费者：

https://blog.csdn.net/u013390476/article/details/52067321



线程只拥有寄存器与栈等资源是相对于其他线程而言的，线程也可以通过malloc申请堆上的资源，但是堆上的资源其他线程是可见的，但是每个线程自己的栈是互不干扰的。

线程申请堆上资源其实是**依赖进程**来动态申请内存，这个内存其实就是进程分给线程的。





## 程序优化

https://blog.csdn.net/ljianhui/article/details/9212817





## STL

总结：迭代器失效分三种情况考虑，也是非三种数据结构考虑，分别为数组型，链表型，树型数据结构。

数组型数据结构：该数据结构的元素是分配在连续的内存中，insert和erase操作，都会使得删除点和插入点之后的元素挪位置，所以，插入点和删除掉之后的迭代器全部失效，也就是说insert(*iter)(或erase(*iter))，然后在iter++，是没有意义的。解决方法：erase(*iter)的返回值是下一个有效迭代器的值。 iter =cont.erase(iter);

链表型数据结构：对于list型的数据结构，使用了不连续分配的内存，删除运算使指向删除位置的迭代器失效，但是不会失效其他迭代器.解决办法两种，erase(*iter)会返回下一个有效迭代器的值，或者erase(iter++).

树形数据结构： 使用红黑树来存储数据，插入不会使得任何迭代器失效；删除运算使指向删除位置的迭代器失效，但是不会失效其他迭代器.erase迭代器只是被删元素的迭代器失效，但是返回值为void，所以要采用erase(iter++)的方式删除迭代器。

注意：经过erase(iter)之后的迭代器完全失效，该迭代器iter不能参与任何运算，包括iter++,*ite


https://blog.csdn.net/daaikuaichuan/article/details/80717222

https://blog.csdn.net/yangquanhui1991/article/details/52077562



面经

https://github.com/huihut/interview#cc





编译过程：

https://www.cnblogs.com/dongdongweiwu/p/4743709.html



py

https://blog.csdn.net/Jerry_1126/article/details/44023949



动态绑定：

https://blog.csdn.net/chgaowei/article/details/6427731





排序算法：

https://www.cnblogs.com/onepixel/p/7674659.html





# 面试

关联容器的Compare必须是strict weak ordering的：

- 不能用 `<=` 或  `>=`  号这个比较规则。因为用  `!(a<=b)&&!(b<=a)` 去看两者相不相等，会发现返回的是 false

对于你重载的<运算符要满足下面三个条件：

1. Strict：s < s 要必须返回false

2. Weak：s < t 和 t < s都返回false时，就说明s == t

3. Ordering：s < t为true 并且 t < z为true，则s < z也必须为true